#!/usr/bin/python

import socket, sys, fcntl, struct, time, thread, threading, Queue, random, logging
from struct import *

MQTT_LOG_INFO=0x01
MQTT_LOG_NOTICE=0x02
MQTT_LOG_WARNING=0x04
MQTT_LOG_ERR=0x08
MQTT_LOG_DEBUG=0x10

LOGGING_LEVEL ={
		MQTT_LOG_INFO : logging.INFO,
		MQTT_LOG_NOTICE : logging.INFO,
                MQTT_LOG_WARNING : logging.WARNING,
		MQTT_LOG_ERR : logging.ERROR,
		MQTT_LOG_DEBUG : logging.DEBUG,
		} 

# Function to check if the topic matches a subscription. Called when a message arrived and the topic compared against the list of subscribed topics.

def topic_matches_sub(str, pattern) : 
        topic=str.split('/')
        sub=pattern.split('/')
        if(len(sub)>len(topic)) :
            return False
        for i in range(len(topic)) :
            if(topic[i]==sub[i] or sub[i]=='+') :
                continue
            else :
                if(sub[i]=='#' and (i+1)>=len(sub)) :
                    return True
                else :
                    return False
        return True

# Callback functions for acknowledging the published and subscribed messages

def subscribe_acknowledge(self) :
     if self.__on_subscribe : 
         self.__on_subscribe()

def publish_acknowledge() :
     if self.__on_publish : 
         self.__on_publish()

# Function to traverse the message which is used to determine if the received message is duplicate.

def queuetraversing(idx,msg_id,ip):
    f=0
    for i in range(list_queue[idx].qsize()) :
        msg=list_queue[idx].get(False)
        if msg[1]==msg_id and msg[2]==ip :
           f=-1
        list_queue[idx].put(msg,False)
    return f

# checksum functions needed for calculation checksum
def checksum(msg):
    s = 0
    
    # loop taking 2 characters at a time
    for i in range(0, len(msg), 2):
	
	if i==(len(msg)-1):
		w=ord(msg[i])
	else:
        		w = ord(msg[i]) + (ord(msg[i+1]) << 8 )
        s = s + w
     
    s = (s>>16) + (s & 0xffff);
    s = s + (s >> 16);
     
    #complement and mask to 4 byte short
    s = ~s & 0xffff
     
    return s

# Receiver thread

def recv(self):

    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)
    except socket.error , msg:
        print 'Socket could not be created. Error Code : ' + str(msg[0]) + ' Message ' + msg[1]
        sys.exit()
    

# receive a packet
    while True:
        packet = s.recvfrom(65565)
        if self.thread_kill.is_set() :
	       self.condition_variable.acquire()
	       self.condition_variable.notify()
    	       self.condition_variable.release()
	       thread.exit()
        self.mutex_lock.acquire()  
	   
    #packet string from tuple
        packet = packet[0]
     
    #take first 28 characters for the ip header
        ip_header = packet[0:28]
  
    #now unpack them 
        iph = unpack('!BBHHHBBH4s4sBBHHH' , ip_header)
     
        version_ihl = iph[0]
        version = version_ihl >> 4
        ihl = version_ihl & 0xF
        iph_length = ihl * 4
        s_addr = socket.inet_ntoa(iph[8]);
        d_addr = socket.inet_ntoa(iph[9]);
        ip_opt = iph[12];
    
        
# Discarding already received packets
        if s_addr == self.source_ip:
	   self.log_messages(MQTT_LOG_DEBUG,'Discarding self originated packets')
           self.mutex_lock.release()
    	   continue
        f=0
        for i in range(len(bidlist)):
    	   if self.bidlist[i][0]==iph[12]:
 		f=1
 		break
        if f==1:
	   self.log_messages(MQTT_LOG_DEBUG,'Discarding already received packets')
	   self.mutex_lock.release()
 	   continue
        udp_header = packet[iph_length:iph_length+8]
     
    #now unpack them :)
        udph = unpack('!HHHH' , udp_header)
     
        source_port = udph[0]
        dest_port = udph[1]
        udp_length=udph[2]
     
        h_size = iph_length + udp_length
        data_size = len(packet) - h_size
     
    #get data from the packet
        data = packet[h_size:]
	header=data[0:16]
        application_header = unpack('!12si' , header)
        msg_ip=socket.inet_ntoa(data[16:20])
	payload=data[20:]
	new_str=application_header[0]
        if msg_ip!=self.source_ip :
	  self.log_messages(MQTT_LOG_DEBUG,'Processing the received Packet') 
          for i in range(len(self.topic_list)) :
	     comp = new_str[:len(self.topic_list[i][0])]
	     if (topic_matches_sub(self.topic_list[i][0],comp)==True) :
                if self.queuetraversing(i,application_header[1],msg_ip)!=0 :
                   break
	        if self.list_queue[i].full()==True:
		   self.list_queue[i].get()
		   self.list_queue[i].task_done()
                self.list_queue[i].put([payload,application_header[1],msg_ip],False)
		self.log_messages(MQTT_LOG_INFO,'Payload added to a message queue')
		self.topic_list[i][1]()
	        break
	else :
	  self.mutex_lock.release()
          continue
	if self.__max_queued_messages==0 :
	  self.log_messages(MQTT_LOG_DEBUG,'Updating the send buffer')  
	  self.bidlist.append([ip_opt,data,self.messages_retry])  
	elif len(bidlist) < self.__max_queued_messages : 
	  self.log_messages(MQTT_LOG_DEBUG,'Updating the send buffer')
          self.bidlist.append([ip_opt,data,self.messages_retry])
	else :
	  self.mutex_lock.release()
	  continue 
	self.condition_variable.acquire()
	self.condition_variable.notify()
    	self.condition_variable.release()
	self.mutex_lock.release()

# Transmitter Thread

def trans(self) : 
    try:
    	s1 = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
    except socket.error , msg:
    	print 'Socket could not be created. Error Code : ' + str(msg[0]) + ' Message ' + msg[1]
    	sys.exit()
 
# tell kernel not to put in headers, since we are providing it, when using IPPROTO_RAW this is not necessary
    
    
    s1.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    if self.indicator=='s' : 
        single_packet=self.inter_packet_time
        burst_packet=0
    elif self.indicator=='b' :
	single_packet=0
	burst_packet=self.inter_packet_time
    else : 
	raise ValueError(' Invalid indicator : Type b or s ')

    while True:
	self.mutex_lock.acquire()
	if len(self.bidlist)!=0:
	    self.log_messages(MQTT_LOG_DEBUG,'Updating send buffer')
	    self.bidlist=[item for item in self.bidlist if item[2]!=0]
	if len(self.bidlist)==0:
	    self.mutex_lock.release()
            self.condition_variable.acquire()
	    self.condition_variable.wait()
	    self.condition_variable.release()
	    if self.thread_kill.is_set() :
	        thread.exit()
	    self.mutex_lock.acquire()
        self.mutex_lock.release()
        for count in range(self.__max_inflight_messages) :     
# now start constructing the packet
	    self.mutex_lock.acquire()
	    self.log_messages(MQTT_LOG_DEBUG,'Broadcasting a packet')
    	    packet = '';
 	    i1,i2,i3,i4=source_ip.split('.')
    	    dest_ip = i1+'.'+i2+'.'+i3+'.255' 
 
# ip header fields
    	    ip_ihl = 7
    	    ip_ver = 4
    	    ip_tos = 0
    	    ip_tot_len = 0  # kernel will fill the correct total length
    	    ip_id = 5432   #Id of this packet
    	    ip_frag_off = 0
    	    ip_ttl = 255
    	    ip_proto = socket.IPPROTO_UDP
    	    ip_check = 0    # kernel will fill the correct checksum
    	    ip_saddr = socket.inet_aton ( self.source_ip )
    	    ip_daddr = socket.inet_aton ( dest_ip )
    	    ip_opt_flag=0
    	    ip_opt_class=2
    	    ip_opt_number=8
    	    ip_opt_length=4
    	    ip_opt_data = self.bidlist[count][0]
    	    ip_opt_zero=0         #  Zero padding
    	    ip_opt_1 = (ip_opt_flag << 7) + (ip_opt_class << 5) + ip_opt_number;
    	    ip_ihl_ver = (ip_ver << 4) + ip_ihl
 
# the ! in the pack format string means network order
    	    ip_header = pack('!BBHHHBBH4s4sBBHHH' , ip_ihl_ver, ip_tos, ip_tot_len, ip_id, ip_frag_off, ip_ttl, ip_proto, ip_check, ip_saddr, ip_daddr,ip_opt_1,ip_opt_length,ip_opt_data,ip_opt_zero,ip_opt_zero)
 
# udp header fields
    	    udp_source = 1235   # source port
    	    udp_dest = 2500   # destination port
    	    udp_check = 0

# the ! in the pack format string means network order

    	    user_data = self.bidlist[count][1]
    	    udp_len= 8;
    	    udp_header = pack('!HHHH' , udp_source, udp_dest,udp_len,udp_check) 
    
# pseudo header fields
    	    source_address = socket.inet_aton( self.source_ip )
    	    dest_address = socket.inet_aton(dest_ip)
    	    placeholder = 0
    	    protocol = socket.IPPROTO_UDP
    	    udp_length = len(udp_header) 
 
    	    psh = pack('!4s4sBBH' , source_address , dest_address , placeholder , protocol , udp_length);
    	    psh = psh + udp_header + user_data;
 
    	    udp_check = checksum(psh)
 
# make the udp header again and fill the correct checksum - remember checksum is NOT in network byte order

    	    udp_header = pack('!HHH' , udp_source, udp_dest,udp_length) + pack('H' , udp_check)
 
# final full packet - syn packets dont have any data
    	    packet = ip_header + udp_header + user_data
            #print 'Sending packet : ' + user_data
	    self.bidlist[count][2]-=1
	      
 
#Send the packet finally - the port specified has no effect
    	    s1.sendto(packet, (dest_ip , 0 ))    # put this in a loop if you want to flood the target
	    self.mutex_lock.release()
	    if self.thread_kill.is_set():
	        thread.exit()
	    #time.sleep(single_packet)
        time.sleep(burst_packet)


class Client :

	receiver=recv
	transmitter=trans

  	def __init__(self, client_id="", clean_session=True, userdata=None, protocol='DWMQ', transport="udp"):
	      self.protocol='DWMQ'
	      self.transport="udp"
	      self.userdata=userdata
	      self.keepalive=60
	      self.__messages_retry=10
	      self.clean_session=clean_session
	      self.__max_inflight_messages=20
	      self.__max_queued_messages=0
	      self.port=2000
	      self.on_connect=None
	      self.on_subscribe=None
	      self.on_publish=None
	      self.on_message=None
	      self.on_unsubscribe=None
	      self.on_disconnect=None
	      self.on_log=None
	      self.condition_variable=threading.Condition()
	      self.mutex_lock=threading.Lock()
	      self.inter_packet_time=10
#global source_ip
	      self.list_queue=[]
	      self.topic_list=[]
	      self.bidlist=[]
	      self.MAXTOPICS=2
	      self.MAXMESSAGES=10
	      self.MAXPAYLOADSIZE=1440
	      self.source_ip=None
	      self.thread_kill=threading.Event()
              self.__logger=None
	

	def __del__(self) :
	      pass

	def max_inflight_messages_set(self,inflight) : 
	      self.__max_inflight_messages=inflight

	def max_queued_messages_set(self,queue_size) :
	      self.__max_queued_messages=queue_size

	def reinitialise(client_id="", clean_session=True, user_data=None) :
	      self.__init__(client_id,clean_session,user_data,'DWMQ',"udp")

	def get_ip_address(self,ifname):
    	      s2 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    	      return socket.inet_ntoa(fcntl.ioctl(s2.fileno(),0x8915,  # SIOCGIFADDR
        struct.pack('256s', ifname[:15]))[20:24])
  
	def enable_logger(self,logger=None) :
              if not logger :
		 if self.__logger : 
                    return
                 self.__logger=logging.getLogger(__name__)
              else :
		    self.__logger=logger

	def disable_logger(self) :
             self.__logger=None

	def log_messages(self,level,message) :
	     if self.on_log :
	         self.on_log(self,self.userdata,level,message)
	     if self.__logger :
		 self.__logger.log(LOGGING_LEVEL[level],message)
 
	def reconnect_delay_set(min_delay=1,max_delay=120) :
	      return
	
	def connect(self,host,port=2000,keepalive=60,bind_address=""):
	      self.log_messages(MQTT_LOG_INFO,'Connecting to the network....')
	      self.host=None
	      self.port=port
	      self.keepalive=keepalive
	      if bind_address==None or len(bind_address)==0 :
	         self.source_ip=self.get_ip_address('eth0') 
	      else :
		 self.source_ip=bind_address
	      self.indicator='b'
              self.receive=threading.Thread(None,self.receiver,"Receiver Thread",)
              self.transmit=threading.Thread(None,self.transmitter,"Transmitter Thread",) 
	      self.receive.start()
	      self.transmit.start()
	      self.log_messages(MQTT_LOG_INFO,'Connected to the network')

	def reconnect(self) :
	      self.log_messages(MQTT_LOG_INFO,'Reconnecting to the network.....')
	      self.receive=threading.Thread(None,self.receiver,"Receiver Thread",)
              self.transmit=threading.Thread(None,self.transmitter,"Transmitter Thread",) 
	      self.receive.start()
	      self.transmit.start()
	      self.log_messages(MQTT_LOG_INFO,'Reconnected to the network')

	def disconnect() :
	      if self.clean_session == True :
	          self.mutex_lock.acquire()
	          del self.topic_list[:]
	          for i in self.list_queue :
	 	      i.queue.clear()
	          del self.list_queue[:]
		  self.thread_kill.set()
		  self.mutex_lock.release()
		  self.receive.join()
	          self.transmit.join()
	      else :
		  self.thread_kill.set()
	          self.receive.join()
	          self.transmit.join()
		  self.log_messages(MQTT_LOG_INFO,'Disconnected')
     
	def unsubscribe(self,topic) :
	      self.mutex_lock.acquire()
	      mid=random.randrange(501,999)
	      if topic==None or len(topic)==0 :
	          raise ValueError(' Topic not provided')
	      elif type(topic) is list : 
		  for msg in topic :
	      	      i=self.topic_list.index(msg)
	              del self.topic_list[i]
	              self.list_queue[i].queue.clear()
	              del self.list_queue[i]
		  self.mutex_lock.release()
		  self.log_messages(MQTT_LOG_INFO,'Unsubscribed topics in the list')
	  	  return (0,mid)
	      elif type(topic) is string :
		  i=self.topic_list.index(msg)
	          del self.topic_list[i]
	          self.list_queue[i].queue.clear()
	          del self.list_queue[i]
		  self.mutex_lock.release()
		  self.log_messages(MQTT_LOG_INFO,'Unsubscribed the topic')
	          return (0,mid)
	      else :
		  raise ValueError('Argument is neither string nor list')
	      self.mutex_lock.release()

	def subscribe(self,msg,qos=0):
    	      global list_queue,MAXTOPICS,MAXMESSAGES
    	      if len(self.list_queue)>=MAXTOPICS :
	                  self.log_messages(MQTT_LOG_ERR,'Subscription limit Exceeded. Could not subscribe')
        		  return [-1,]
    	      else :
		  if msg==None or len(msg)==0 :
	   		raise ValueError(' Topic not provided ')
		  mid=random.randrange(501,999)
		  self.mutex_lock.acquire()
		  if type(msg) is tuple :
	   		self.topic_list.append([msg[0],self.funcptr,mid])
	   		self.list_queue.append(Queue.Queue(MAXMESSAGES))
			self.log_messages(MQTT_LOG_INFO,'Subscribed to the topic')
		  elif type(msg) is list :
	   		for i in msg :
	       		    self.topic_list.append([i[0],self.funcptr,mid])
	       		    self.list_queue.append(Queue.Queue(MAXMESSAGES))
			self.log_messages(MQTT_LOG_INFO,'Subscribed to the list of topics')
		  elif type(msg) is str :
	   		self.topic_list.append([msg,self.funcptr,mid])
	   		self.list_queue.append(Queue.Queue(MAXMESSAGES))
			self.log_messages(MQTT_LOG_INFO,'Subscribed to the topic')
			
		  else :
	   		    raise ValueError(' Argument is neither tuple nor string nor list ')
		  self.mutex_lock.release()
                  return [0,mid]

	def Publish(self,topic,msg=None,qos=0,retain=False):
    	      ip=''.join(bin(int(x)+256)[3:] for x in self.source_ip.split('.'))
    	      ip=pack('!I',int(ip,2))
    	      msg_id= random.randrange(1,500)
    	      broadcast_id=random.randrange(1000,2000)
    	      payload=pack('!12si',topic,msg_id)+ip+str(msg)
	      if topic==None or len(topic)==0 :
	 	  raise ValueError(' Topic not provided or invalid topic name ')
	      elif any(wildchar in topic for wildchar in ['+','*','.','#']) :
		  raise ValueError(' Invalid Topic')
    	      elif len(payload)<=MAXPAYLOADSIZE :
       		  lock.acquire()
       		  bidlist.append([broadcast_id,payload,self.messages_retry])
       		  lock.release()
       		  cv.acquire()
       		  cv.notify()
       		  cv.release()
		  self.log_messages(MQTT_LOG_INFO,'Published the message')
       		  return [0,msg_id]
    	      else:
	  	  raise ValueError(' Payload exceeded the maximum size ')
